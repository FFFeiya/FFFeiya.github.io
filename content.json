{"pages":[{"title":"About","text":"","link":"/About/index.html"},{"title":"Friends","text":"","link":"/Friends/index.html"},{"title":"Music","text":"Music Recommendation Weekly","link":"/Music/index.html"},{"title":"【Cubase】Midi轨和乐器轨","text":"Midi轨和乐器轨到底有什么区别呢？ 在Cubase中，我们右键单击图示红框处，会弹出下面这个选项条： 我们看最上面三个选项，音频轨道不难猜出，是添加音频文件的。 我们按下F11后，打开了VST乐器界面。 我在这里选择挂载了一个Kontact 5，这是一个支持多轨道的乐器。 挂载了乐器之后，Cubase就会自动提示是否要为该乐器创建一个Midi轨。我们点创建就行了。 [未完]","link":"/Music/Cubase/index.html"}],"posts":[{"title":"Manacher[Cover.NOIP模拟赛]","text":"[我们这里还有鱼] Problem B. 序列对于一个长度为偶数的序列 a1,a2,a3,…,an， 定义这个序列为好的序列，当且仅当 a1 + an = a2 + an−1 = a3 + an-2 = …… 定义一个对序列的翻滚操作，使所有元素向前移一个位置，第一个元素移到最后的位置。 现在小 A 有一个长度为偶数的序列 b1,b2,b3,…,b3，他想知道至少需要翻滚多少次才能使这个序列 成为好的序列。 马拉车是什么？ (大误) Manacher’s Algorithm，是一个叫做Manacher的人发明的一种线性求字符串最长回文子串的方法。 Manacher’s Algorithm现在我们有两种回文串的类型：CABAC &amp; CABBAC，那么怎么处理呢？如果分类讨论的话太丑陋，一个好的算法就应该男女通吃。我们考虑在每两个字符中插入一个’#’，这样的话就成了#C#A#B#A#C# &amp; #C#A#B#B#A#C#，我们可以发现，这两个字串都是一种类型的了：从某一个字符向两边对称。再考虑这个字串的长度，因为在每个字符的右边加了一个’#’，又在字符串末尾加了一个’#’，所以有 S处理后字符串=S原字符串*2+1。 我们在暴力找回文子串的时候，是枚举当每个字符为一个回文子串的中心，再向两边暴力拓展。在这里我们可以把每一个以第i个字符为中心的最长回文子串的半径记为P[i] (我们考虑半径就是$(Len+1)/2$ ,反推则回文子串长度为$2*P[i]-1$) 接下来我们考虑一个问题，ABCBABCBA这个字符串，我把它的P数组记录下来： i 0 1 2 3 4 5 6 7 8 P[i] 1 1 3 1 5 1 3 1 1 我们先考虑P[2]，P[2]的最长回文子串为：ABCBA。我们再考虑P[6]，P[6]的最长回文子串也为：ABCBA。排除巧合的可能，真相只有一个，这一定有什么原因在里面。我们考虑第4位，不难发现，由第4位拓展出的回文子串覆盖了0~8位字符。那么，0~3位和5~8位应该是完全对称的！所以我们算到在第4位后面的字符的时候，它的初始P[i]就应该是对称回去的P值！ 接下来我们考虑怎么实现这个对称优化：我们维护两个值，mx，id。mx表示算到现在之前的回文子串所覆盖到的最右点，id表示覆盖到该最右点的子串的中心点。在计算某一个字位的P值时，我们先看一下该字位是否在之前的回文子串所覆盖的范围内，如果在，则该P值先赋为对称过去的那个点的P值。但是，我们还得注意，对称过去的P值有可能会超出了id所在回文子串的覆盖范围。碰到这种情况，只需要在P[id*2-i]和mx-i取min值就行了。另外当当前字位不在mx范围内，不妨先把半径设为1，表示目前可知最大回文就是它本身。赋完初值后，接下来再暴力向外拓展就行了。 1234567if (mx&gt;i) p[i]=min(p[id*2-i],mx-i);else p[i]=1;for (int j=i+p[i];j&lt;s.size();j++)&#123; if (j&gt;mx) mx=j,id=i; if (s[j]==s[2*i-j]) p[i]++; else break;&#125; 现在我们知道了字符串每一位的P值，我要是想知道以某一位(一般来讲是求最大位)为中心的回文子串在原串中的起始位置呢？ 我们考虑一下，字符串是”%QXQ”这种情况。现在我们知道的P值，是以”#%#Q#X#Q#”为基础的。考虑’X’位，它的半径是4，在处理后的字串中位置是5。当我们用该位置减去(半径/2)(半径中原字符和’#’数量相等)，就得到了在回文子串前一位的字符’%’的位置。我们可以发现，前面的原字符和’#’数量也等，于是也要除以2。于是我们得到了这样的公式（设处理后字符的位置为W0​）：W原字符=(W0+1-P[W0])/2 (要注意字符串开头标号是0哦) 这样我们得到了以下代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;//祈福无Bug#define N 100005using namespace std;string change(string &amp;s)&#123; string ans=\"#\"; for (int i=0;i&lt;s.size();i++)&#123; ans.push_back(s[i]); ans.push_back('#'); &#125; return ans;&#125;string str;int p[N];int mx,id;int manacher(string &amp;s)&#123; int ans=0;mx=0; for (int i=0;i&lt;s.size();i++)&#123; if (mx&gt;i) p[i]=min(p[id*2-i],mx-i); else p[i]=1; for (int j=i+p[i];j&lt;s.size();j++)&#123; if (j&gt;mx) mx=j,id=i; if (s[j]==s[2*i-j]) p[i]++; else break; &#125; ans=max(ans,p[i]); &#125; return ans-1;&#125;int main(void)&#123; cin&gt;&gt;str; str=change(str); cout&lt;&lt;manacher(str)&lt;&lt;endl;&#125; 我们考虑他的复杂度，这个算法求解就是一个对mx更新的过程，对mx的更新是线性的，所以考虑复杂度为$O(n)$。 对马拉车算法的应用(在模拟赛中是马翻车) Problem B. 序列输入文件： sequence.in输出文件： sequence.out时间限制： 1 秒内存限制： 512 MiB题目描述：对于一个长度为偶数的序列 a1, a2, a3, . . . , an，定义这个序列为好的序列，当且仅当 a1 + an = a2 + an−1 = a3 + an−2 = . . . = a n2+ a n2 +1。定义一个对序列的翻滚操作，使所有元素向前移一个位置，第一个元素移到最后的位置。现在小 A 有一个长度为偶数的序列 b1, b2, b3, . . . , bn，他想知道至少需要翻滚多少次才能使这个序列成为好的序列。 输入：第一行一个整数 n 表示序列的长度，保证 n 为一个偶数。第二行 n 个正整数，第 i 个数表示 bi。 输出：如果有解，输出一个正整数，表示最少需要翻滚多少次才能使这个序列成为好的序列。如果没有解，输出 IMPOSSIBLE。 样例输入：6 2 8 7 9 1 3 样例输出：1 限制：对于 30% 的数据，n ≤ 1000。 对于 60% 的数据，n ≤ 200000。 对于 100% 的数据，n ≤ 1000000，bi ≤ 1000000。 咋一看这道题，非常棘手，但是在经过我两个小时的仔细思考后，我还是觉得非常棘手。我们可以观察一下样例，对成功变化过的样例相邻两数做差。 我们发现了什么！回……回文子串！ 对于任意这个数列中相对的任意两组数，我们把他设为 a b B A，a+A=b+B，进行简单的移位后，我们得到a-b=B-A，两两相邻的数相减，就可以得到一个回！文！数！列！所以求差后的如果能得到回文序列的序列，就是”好的序列”！ 接下来我们考虑进行马拉车了。考虑一个有解的数列，它一定是由两个”好的序列”构成的。假设一个”好的序列”，将它的最后一位移到第一位，第一位与原第二位相加还是符合原数列的标准，所以第一位和第二位可以构成一个”好的序列”。再把后面的数移上来……以此类推。 那么接下来我们的任务就是找到两个刚好填满空间的回文序列，并且使前一个序列尽可能小。 我们考虑回文序列为数组b，原序列为数组a。 1b[i]=a[i-1]-a[i]; 于是从前往后枚举，判断每一位作为前一个回文序列的中心，写下以下代码： 1234if (p[i]==i &amp;&amp; p[n/2+i]==n/2-i+1)&#123; printf(\"%d\\n\",i-1); return 0; &#125; 其中计算i对应的另外一个序列的中心的位置很容易算错…… 完整代码以下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;//祈福无Bug#define N 1000005#define INF 10000005#define min(x,y) ((x&lt;y)?(x):(y))#define max(x,y) ((x&gt;y)?(x):(y))using namespace std;int n;int a[N],b[N],p[N];void read(int &amp;x)&#123; char c; while((c=getchar())&lt;'0' || c&gt;'9'); x=c-'0'; while((c=getchar())&gt;='0' &amp;&amp; c&lt;='9') x=x*10+c-'0';&#125;int main(void)&#123; //freopen(\"sequence8.in\",\"r\",stdin); read(n); for (int i=1;i&lt;=n;i++) read(a[i]); a[0]=a[n]; for (int i=1;i&lt;=n;i++) b[i]=a[i-1]-a[i]; b[0]=INF;b[n+1]=-INF; int mx=1,id=p[1]=1; for (int i=2;i&lt;=n;i++)&#123; if (i&lt;=mx) p[i]=min(p[id*2-i],mx-i+1); else p[i]=1; while (b[i+p[i]]==b[i-p[i]] &amp;&amp; i+p[i]&lt;=n) p[i]++; if (mx&lt;i+p[i]-1) mx=i+p[i]-1,id=i; &#125; for (int i=1;i&lt;=n;i++)&#123; if (p[i]==i &amp;&amp; p[n/2+i]==n/2-i+1)&#123; printf(\"%d\\n\",i-1); return 0; &#125; &#125; printf(\"IMPOSSIBLE\\n\");&#125; 咕咕咕！QXQ快找彩蛋！","link":"/2018/10/28/Manacher-Cover-NOIP模拟赛/"},{"title":"First Blog","text":"","link":"/2018/10/18/First Blog/"},{"title":"Splay基本操作[ft.指针]","text":"[怎么用C++自带的指针写数据结构？] [不会……那就快点学！不要颓！] 第一次用指针完成高级数据结构の[Splay]Splay食用须知首先，我们要理解什么是Splay树。Splay树是一棵二叉搜索树：二叉搜索树，用LJ的话讲，就是“左边比它小，右边比他大”。我们考虑这样一棵树，树上的任意一个节点满足“他的左子树上的每一个节点的值都比该节点的值小，他的右子树上的每一个节点的值都比该节点的值大”。就像这样： 如果这棵二叉搜索树是完全二叉树的话，很显然，查找一个值的时间是O(logn)。但是万一数据使这棵树被构造成一条链的话(例如最小的元素为根节点，次小的元素是它的左节点，以此类推)，查询一个值的时间复杂度会退化为O(n)，你就会获得0分的好成绩。 那么Splay树如何解决这个问题呢？旋转！每一次操作都旋转！跳跃！闭着眼！把节点旋转到根！在这里，我们把将某一个节点旋转到另一个位置，并且使这棵树保留原来的性质的操作，称为Splay。旋转降低复杂度(玄学)，对OIer来讲是无须证明，只要记住就好了，(如果你一定要看证明，你会回来的)。可以感性理解一下，每次操作改变一次结构，被查询频率高的条目会更靠近树根，时间有多有少，平均下来复杂度就会比较低（另外，Splay操作是单旋还是双旋也会影响到复杂度）。 成员变量我们先考虑Splay树上每一个点应该包含这几个成员变量： 1234567891011class node&#123;public: int val,cnt,siz; node* fth; node* son[2]; node(int v=0,node *f=NULL)&#123; val=v;fth=f; son[0]=son[1]=NULL; cnt=siz=0; &#125;&#125; val:该点的值 cnt:值为该点的值的个数 siz:包括该点与其左右子树的大小 fth:爸爸指向该点的父节点的指针 son:指向该点的左右子节点的指针([0]左[1]右) Rotate[单旋]现在我们考虑将一个点旋转到它的父节点的位置:我们称其为Rotate。左子节点旋转到父节点称为右旋，右子节点旋转到父节点称为左旋。 在看Rotate的具体步骤之前，我们先介绍这个函数： 123bool sn(void)&#123; return (fth-&gt;son[1]==this);&#125; (注:这个函数是node这个类的成员函数，this是指向自己的指针，可以删去，下面的Rotate函数和Splay函数同理，不清楚可以看文章最后的全代码) 这个函数Sn可以方便地判断this是其父节点的哪个儿子，并返回该儿子的下标。 12345678910111213void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; y-&gt;updata(),this-&gt;updata();&#125; 其中注意，我们可以通过Sn()这个函数判断this是它父节点的哪一个子节点，以此来判断是左旋还是右旋，就不用累赘地写两个函数了。 这样，我们就完成单旋了。单旋Splay就是对某一个节点疯狂做单旋直到它变到目标位置。在多年(我考了十八年NOIP了，连复赛的机子都没摸到过)OI学习中，我们可以感觉到，做事不·能太暴力，单旋Splay是不能彻底改变树的结构的，(稍微卡一卡就咕咕)，于是我们引入了：“双旋Splay”，来彻底做到玄学复杂度。 Splay[双旋] 我们先观察上面的两张图，这次我们要考虑x(this)节点的父亲节点和祖父节点，分别命名为P，Q。如果x和p是同一种子节点(左/右子节点)，执行Zig-Zig操作，将x旋转到Q的位置，反之，执行Zig-Zag操作，将x旋转到Q的位置。这样子旋转两次直到x被旋转到目标节点——这就是双旋Splay。每次做两个Rotate操作，但是要注意的是，如果x与目标节点的深度只差1时，只用执行一次Rotate操作就可以了。(这样就可以保证复杂度的玄学了！) Zig-Zig操作：先旋转P节点，再旋转X节点； Zig-Zag操作：旋转两次X节点。 123456789101112131415161718bool splay(node* y=NULL)&#123; while(this-&gt;fth!=y)&#123; if (this-&gt;fth==NULL) return false; node *p=this-&gt;fth; if (p-&gt;fth==y || p-&gt;fth==NULL)&#123; this-&gt;rotate(); continue; &#125; node *q=p-&gt;fth; if (this-&gt;sn()!=p-&gt;sn())&#123; this-&gt;rotate(); this-&gt;rotate(); &#125; else&#123; p-&gt;rotate(); this-&gt;rotate(); &#125; &#125; return true;&#125; (这里我们考虑返回Bool值，在x转不到目标节点的情况能做出判断，用处不大) 这样子，我们的类-Node就打好了！这样就完成了一个Splay的框架。 类Node的完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class node&#123;public: int val,cnt,siz; node* fth; node* son[2]; node(int v=0,node *f=NULL)&#123; val=v;fth=f; son[0]=son[1]=NULL; cnt=siz=0; &#125;private: bool sn(void)&#123; return (fth-&gt;son[1]==this); &#125; void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; &#125;public: bool splay(node* y=NULL)&#123; while(this-&gt;fth!=y)&#123; if (this-&gt;fth==NULL) return false; node *p=this-&gt;fth; if (p-&gt;fth==y || p-&gt;fth==NULL)&#123; this-&gt;rotate(); continue; &#125; node *q=p-&gt;fth; if (this-&gt;sn()!=p-&gt;sn())&#123; this-&gt;rotate(); this-&gt;rotate(); &#125; else&#123; p-&gt;rotate(); this-&gt;rotate(); &#125; &#125; return true; &#125;&#125;; Insert[插入][在一个二叉搜索树中如何插入一个新的节点？] [找到你的归宿，一层一层剥开。] 对于一个Splay树，我们只记录他的根节点，由root指针指向。所以做什么操作，都要从源头开始。从根出发，如果比根大，就往根的右子树里找，如果比根小，就往根的左子树找。 在树状结构中，这样的查找是不是让人很想用递归实现啊？ 12345678910111213void _insert(int v,node *p,node *f)&#123; if (p==NULL)&#123; p=new node(v,f); p-&gt;splay(); root=p; return; &#125; if (v==p-&gt;val)&#123; p-&gt;cnt++; return; &#125; if (v&lt;p-&gt;val) _insert(v,p-&gt;son[0],p); if (v&gt;p-&gt;val) _insert(v,p-&gt;son[1],p);&#125; 但是其实可以用循环实现哦~这样子调用函数，传入多个参数，又慢又丑陋，不如这样写: 12345678910111213void insert(int v)&#123; if (root==NULL) root=new node(v,NULL); for (node *t=root;;t=t-&gt;son[v&gt;=t-&gt;val])&#123; if(t-&gt;val==v)&#123; root=t; t-&gt;cnt++; t-&gt;splay(); return; &#125; if (t-&gt;son[v&gt;=t-&gt;val]==NULL)&#123; t-&gt;son[v&gt;=t-&gt;val]=new node(v,t); &#125; &#125;&#125; 如果原有该值的点，则直接cnt++，如果没有，则new一个新的点再cnt++。 (不管怎么样，操作中都要Splay操作结点) Find[查找]从root往下找，走向son[v&gt;t-&gt;val]——当v大于当前节点的val时，返回1：走向右子树；当v小于当前节点的val时，返回0：走向左子树。 12345678910node* find(int v)&#123; for(node* t=root;t;t=t-&gt;son[v&gt;t-&gt;val])&#123; if(t-&gt;val==v)&#123; t-&gt;splay(); root=t; return t; &#125; &#125; return NULL;&#125; Erase[删除]先Splay要删去的节点——好，现在我们要删去的节点在根节点上。 接下来，在他的左子树中找到最大的那个节点，（如果没有左子树的话就直接删去根节点就行了），将那个节点Splay到根节点的右子节点，那么此时这个节点是没有右子树的——将根节点的左子树指向这个节点，干脆利落地删除根节点，删除操作完成！ size[子树大小]在这里，我们在node类中引入updata函数，在Rotate操作中将改变的size值更新。 1234void updata(void)&#123; siz=(son[0]?son[0]-&gt;siz:0) +(son[1]?son[1]-&gt;siz:0)+cnt;&#125; 这是改变后的Rotate操作： 12345678910111213void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; y-&gt;updata(),this-&gt;updata();&#125; 那么返回一个节点及其子树的Size就非常简单了。 123456int size(void)&#123; return root-&gt;siz;&#125;int size(node* x)&#123; return x-&gt;siz;&#125; #####Kth[第K大数] 如果K在根节点的cnt区间内，则返回根节点; 如果K在左子树区间内，递归处理左子树; 如果K在右子树区间内，将在之后的递归中加入当前左子树和根节点的值，递归处理右子树。 递归处理，简单明了。 1234567891011121314151617int kth(int key)&#123; int cnt=0; if (key&gt;root-&gt;siz) return -1; for (node* i=root;i;)&#123; int lcnt=(i-&gt;son[0])?i-&gt;son[0]-&gt;siz:0; int mcnt=i-&gt;cnt; if (cnt+lcnt&lt;key &amp;&amp; cnt+lcnt+mcnt&gt;=key)&#123; i-&gt;splay(); return i-&gt;val; &#125; if (cnt+lcnt&gt;=key) i=i-&gt;son[0]; if (key&gt;cnt+lcnt+mcnt)&#123; cnt+=lcnt+mcnt; i=i-&gt;son[1]; &#125; &#125;&#125; Next[前驱/后继]找前驱，在该节点的左子树中向右子树找，找出左子树中最大的节点。 找前驱，在该节点的右子树中向左子树找，找出右子树中最小的节点。 1234567node* next(node* x,int s)&#123; //s=0表示前驱，s=1表示后继 node* t=x-&gt;son[s]; if (!t) return NULL; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; t-&gt;splay(); return t;&#125; 与Find函数结合，可以先找到该节点，再进行Next操作。 1234567int next(int ix,int s)&#123; //s=0表示前驱，s=1表示后继 node* x=find(ix); node* t=x-&gt;son[s]; if (!t) return -1; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; return t-&gt;val;&#125; Main[主程序]这样，我们的Splay就支持了以下操作： Erase Insert Find Size Kth Next 1234567891011121314151617181920212223242526272829303132333435363738394041int n,tmp,z;string s;Splay tr;int main(void)&#123; for(;;)&#123; cin&gt;&gt;s; if (s==\"erase\")&#123; cin&gt;&gt;tmp; tr.erase(tmp); tr.print(); &#125; if (s==\"insert\")&#123; cin&gt;&gt;tmp; tr._insert(tmp,tr.root,NULL); tr.print(); &#125; if (s==\"find\")&#123; cin&gt;&gt;tmp; if (tr.find(tmp)) cout&lt;&lt;\"true\\n\"; else cout&lt;&lt;\"false\\n\"; tr.print(); &#125; if (s==\"size\")&#123; cout&lt;&lt;tr.size()&lt;&lt;endl; tr.print(); &#125; if (s==\"kth\")&#123; cin&gt;&gt;tmp; cout&lt;&lt;tr.kth(tmp)&lt;&lt;endl; tr.print(); &#125; if (s==\"next\")&#123; cin&gt;&gt;tmp&gt;&gt;z; cout&lt;&lt;tr.next(tmp,z)&lt;&lt;endl; tr.print(); &#125; if (s==\"exit\")&#123; return 0; &#125; &#125;&#125; 完整程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include&lt;bits/stdc++.h&gt;//祈福无Bugusing namespace std;struct node&#123;public: int val,cnt,siz; node* fth; node* son[2]; node(int v=0,node *f=NULL)&#123; val=v;fth=f; son[0]=son[1]=NULL; cnt=siz=0; &#125;private: bool sn(void)&#123; return (fth-&gt;son[1]==this); &#125; void updata(void)&#123; siz=(son[0]?son[0]-&gt;siz:0) +(son[1]?son[1]-&gt;siz:0)+cnt; &#125; void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; y-&gt;updata(),this-&gt;updata(); &#125;public: bool splay(node* y=NULL)&#123; while(this-&gt;fth!=y)&#123; if (this-&gt;fth==NULL) return false; node *p=this-&gt;fth; if (p-&gt;fth==y || p-&gt;fth==NULL)&#123; this-&gt;rotate(); continue; &#125; node *q=p-&gt;fth; if (this-&gt;sn()!=p-&gt;sn())&#123; this-&gt;rotate(); this-&gt;rotate(); &#125; else&#123; p-&gt;rotate(); this-&gt;rotate(); &#125; &#125; return true; &#125;&#125;;struct Splay&#123; node *root; Splay(node *p=NULL)&#123; root=NULL; &#125; int size(void)&#123; return root-&gt;siz; &#125; int size(node* x)&#123; return x-&gt;siz; &#125; void _print(node *x)&#123; if (x==NULL) return; cout&lt;&lt;x-&gt;val&lt;&lt;\" \"; if (x-&gt;son[0]!=NULL) cout&lt;&lt;\"Left:\"&lt;&lt;x-&gt;son[0]-&gt;val&lt;&lt;\" \"; else cout&lt;&lt;\"Left:NULL \"; if (x-&gt;son[1]!=NULL) cout&lt;&lt;\"Right:\"&lt;&lt;x-&gt;son[1]-&gt;val&lt;&lt;\" \"; else cout&lt;&lt;\"Right:NULL \"; cout&lt;&lt;\"\\n\"; _print(x-&gt;son[0]);_print(x-&gt;son[1]); &#125; void print(void)&#123; _print(root); &#125; void insert(int v=0)&#123; if (root==NULL) root=new node(v,NULL); for (node *t=root;;t=t-&gt;son[v&gt;=t-&gt;val])&#123; if(t-&gt;val==v)&#123; root=t; t-&gt;cnt++; t-&gt;splay(); return; &#125; if (t-&gt;son[v&gt;=t-&gt;val]==NULL)&#123; t-&gt;son[v&gt;=t-&gt;val]=new node(v,t); &#125; &#125; &#125; void _insert(int v,node *p,node *f)&#123; if (p==NULL)&#123; p=new node(v,f); p-&gt;splay(); root=p; return; &#125; if (v&lt;p-&gt;val) _insert(v,p-&gt;son[0],p); if (v==p-&gt;val)&#123; p-&gt;cnt++; return; &#125; if (v&gt;p-&gt;val) _insert(v,p-&gt;son[1],p); &#125; node* find(int v)&#123; for(node* t=root;t;t=t-&gt;son[v&gt;t-&gt;val])&#123; if(t-&gt;val==v)&#123; t-&gt;splay(); root=t; return t; &#125; &#125; return NULL; &#125; bool erase(int v,int cnt=1)&#123; node *t=find(v); if (t==NULL)&#123; return false; &#125; if (t-&gt;cnt&gt;cnt)&#123; t-&gt;cnt-=cnt; return true; &#125; if (t-&gt;son[0]==NULL)&#123; root=t-&gt;son[1]; if (root!=NULL) root-&gt;fth=NULL; return true; &#125; node *p=t-&gt;son[0]; while(p-&gt;son[1]!=NULL) p=p-&gt;son[1]; p-&gt;splay(t); root=p; root-&gt;fth=NULL; p-&gt;son[1]=t-&gt;son[1]; if (p-&gt;son[1]!=NULL) p-&gt;son[1]-&gt;fth=p; return true; &#125; int kth(int key)&#123; int cnt=0; if (key&gt;root-&gt;siz) return -1; for (node* i=root;i;)&#123; int lcnt=(i-&gt;son[0])?i-&gt;son[0]-&gt;siz:0; int mcnt=i-&gt;cnt; if (cnt+lcnt&lt;key &amp;&amp; cnt+lcnt+mcnt&gt;=key)&#123; i-&gt;splay(); return i-&gt;val; &#125; if (cnt+lcnt&gt;=key) i=i-&gt;son[0]; if (key&gt;cnt+lcnt+mcnt)&#123; cnt+=lcnt+mcnt; i=i-&gt;son[1]; &#125; &#125; &#125; node* next(node* x,int s)&#123; //s=0表示前驱，s=1表示后继 node* t=x-&gt;son[s]; if (!t) return NULL; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; t-&gt;splay(); return t; &#125; int next(int ix,int s)&#123; //s=0表示前驱，s=1表示后继 node* x=find(ix); node* t=x-&gt;son[s]; if (!t) return -1; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; return t-&gt;val; &#125;&#125;;int n,tmp,z;string s;Splay tr;int main(void)&#123; for(;;)&#123; cin&gt;&gt;s; if (s==\"erase\")&#123; cin&gt;&gt;tmp; tr.erase(tmp); tr.print(); &#125; if (s==\"insert\")&#123; cin&gt;&gt;tmp; tr._insert(tmp,tr.root,NULL); tr.print(); &#125; if (s==\"find\")&#123; cin&gt;&gt;tmp; if (tr.find(tmp)) cout&lt;&lt;\"true\\n\"; else cout&lt;&lt;\"false\\n\"; tr.print(); &#125; if (s==\"size\")&#123; cout&lt;&lt;tr.size()&lt;&lt;endl; tr.print(); &#125; if (s==\"kth\")&#123; cin&gt;&gt;tmp; cout&lt;&lt;tr.kth(tmp)&lt;&lt;endl; tr.print(); &#125; if (s==\"next\")&#123; cin&gt;&gt;tmp&gt;&gt;z; cout&lt;&lt;tr.next(tmp,z)&lt;&lt;endl; tr.print(); &#125; if (s==\"exit\")&#123; return 0; &#125; &#125;&#125; 下一篇文章:Splay区间操作[ft.指针]，过几天会咕咕咕地更新哦。","link":"/2018/10/24/Splay基本操作-ft-指针/"},{"title":"NOIP2018[记我的退役]","text":"以此文，与汝，于己，记亦奠。 2018,11月11日,学军中学紫金港校区,NOIP提高组D区 非常沮丧，但似乎也在意料之中。 在初赛考完就叫嚷着退役退役，等到退役真正到来这一天心里还是有一点空落落的。考场上留下不少遗憾，但最终归根还是自己实力不足，不论最后成绩如何，可以说拿到的每一分都是神的恩赐。期望于己……还是太高了，不论是实力，还是运气。 学OI的道路，回首，有热血，热血的是自己的一厢情愿。中考前的一厢情愿想着拿到普及省一能特招，现在又一厢情愿地想拿到提高省一继续在机房当个老赖。初中是名落孙山，这次自也是难逃命运。 2018,6月,杭州第二中学,四楼机房 中考结束，懵懂来到二中机房，实是无知无畏，和CZhou大佬每天无忧无虑地刷刷DP地狱训练，自得其乐。后来开始打模拟赛，看到排名表的时候才知道自己和大家有多大的差距。初中的我从未得到系统的OI训练，这里的一切都使我新奇无比。那时我还只是从榜中知道了你们的姓字，并不熟识，亦不知诸位的喜悲脾性。但我那个时候我第一次无比自豪地感受到，我属于一个团队，一个全国数一数二的省里的一个数一数二的OI团队。那个时候还不知颓废，写题累了找CZhou或者Lightece聊聊天就打发了时间。现在回首，那时的我正是一个在努力适应这个可爱亦可怖学校的一介莽生，是一个逐渐接受自己OIer身份的初生牛犊。我认清了自己去考普及的时候根本不算一个OI选手，仅仅是爱好：或者是碰运气罢了。整个暑假在机房里待下来，DP刷了不少，算法也稍微学了一些，（现在想那个时候应该多学一点的），但是DP也没有刷到LJ说的那个顿悟的境界。 日月升落，暑假在转眼间倏尔远逝，在暑假前看来好难的算法/数据结构，线段树树状数组最短路最小生成树，都成了基础。在两个月间，我完成了从普及到提高的转换，也因匆匆忙忙，无人带领，在搭建算法/数据结构的框架中还是留下了不少漏洞，有些本因熟练掌握的算法我却只是浅浅了解。到现在我还有些基础算法没有“应用自如”，也为了今天的考场上的爆炸埋下伏笔吧。 2018,9月,杭州第二中学,五楼机房 开学，新班级，新寝室，也不再和小胖胖他们同起居了。我拉着ZZmo他们坐到楼上机房来了：也在此时，我经历了第一次OIer间的离别。CZhou最后还是放弃了信息这条路。我一方面感到难受，一方面对自己也产生些许怀疑——事实证明CZhou的选择可能是及时止损的最好方法，但是我也不后悔当时的坚持。可能是不撞南墙不回头的性格使然吧。一开始坐在LJ旁边，可能LJ感觉我老是看他打隔膜有点不爽了，后来就叫我坐到ZBY旁边了。渐渐跟你们混熟了，也学会了颓废，每天回寝室开个网和QXQWLW疯狂颓，下午到体育馆和大家狼人杀。还是在慢慢学算法，每天打打模拟赛，但是老是爆零，有什么不懂的就到前面来问Zqlwmatt，要么就到后面去问小胖胖，这种有大佬带着的感觉真的不错。开学后乃至停课后都是一个在学习的过程，学了好多新的算法，好多神奇的数据结构，但是还是没有达到大家的水准。我的时间确实不太够，学习了没有那么多时间去巩固，经常过一个礼拜就忘记了之前学的算法，有些查漏补缺了，有些漏洞就一直在那里了。还有对于一些常见算法/数据结构的神奇应用，因为我一直在学板子，对于题目的转化就停留在小聪明上。我不知道这样的我是否做到了我能做到的最好，只能说这段时间是非常充实的。和几个月前的自己比，我感觉自己成长了很多。我的实力很弱，也一直希冀有朝一日能赶上你们。我最感激的是你们没有就我OI实力哪怕只有一点嘲笑，给了我足够的尊重与帮助，让我能够有勇气在这条道路上追逐。 2018,10月13日,十四中风起校区 接下来就是初赛。初赛我真的差点退役了，不管是赛前赛后我都清晰并且坚定地认为我的OI生涯到此为止。学军给CCF氪金救了我一命。初赛我也不想再说了……现在想想有些后悔的是初赛完了以为自己退役稳健了在机房疯狂颓废。ZBY他们没过初赛，我挺难受的，看着他们离开机房，回到教室学文化课，我的心就会掠过一阵酸楚。这对一个OIer来说，该是多么致命的打击啊！我很敬佩ZBYWZX他们的坚强，我也真心不愿意失去这样优秀的队友。 2018,11月9日(Open Day),五楼机房 NOIP前一天按照惯例是Open Day，但是怀着对前途的忐忑我还是没有Open起来。那天下午我和Zqlwmatt在走廊里吃烤鸡的时候，我就在想，明天将是一个OIer生涯的转折点，我和Zqlwmatt，和机房里的大家，命运交汇于此，又会如何分开？与你们，我觉得都应该当很久很久的朋友，可是我害怕，退役离开了，就不再能有这样，如此单纯的终日谈论最喜欢的学科的机会了！OI是我最爱的学科，你们是我最爱的你们，这样幸福的生活我不愿失去啊！我也不甘，我还没能追上你们呢！再给我一年，我想和你们一样，不再担心前途困顿，能在谈笑间毒瘤题灰飞烟灭。 $“情难自已，唏嘘不止”$ 2018,11月11日,23点,男生宿舍 最后是在寝室的床上完成这篇退役之文的。这篇文章是写给你们的，也是写给自己的。我确实需要一个挫折来打醒自己了：打醒这个年少无知，一厢情愿的自己了。满是伤痕地从泥沼爬起来，我曾经历过一次，当然也不怕经历这第二次。下一个赛季，我会卷土重来的，OI，等我。 $“何ページもついやして 綴られた僕らの気分” $","link":"/2018/11/12/【NOIP2018】记我的退役/"},{"title":"Simpson自适应公式[with.Willem]","text":"向Willem爷学习了Simpson自适应公式。 先是做 [NOI2004]降雨量 这题，看到题解里面说可以使用Simpson自适应公式，于是向Willem爷了解了一下。膜膜Willem大爷。 先说积分：积分（integral）的几何意义是函数的曲线上 $x​$ 的一段区间与 $x​$ 轴围成的曲边梯形的面积。 例如该函数的积分记作$$\\int_a^b {f(x)} \\,{\\rm d}x​$$。 如何求这个函数的积分呢？Simpson自适应公式就是其中的一种方法。 Simpson公式就是将复杂的函数 $f(x)​$ 近似拟合成二次函数，再通过二次函数算积分的方法对于$f(x)​$的积分进行估算。下面这个就是Simpson公式。 $$\\int_a^b {f(x)} \\,{\\rm d}x≈\\frac {(b−a)(f(a)+f(b)+4f(\\frac{a+b}{2}))} {6}​$$ 但是这个公式算出来的只是一个近似值。题目要求精度怎么办？ 自适应就是求积分时能够自动控制切割的区间大小和长度，使精度能满足要求。 来看这行代码： 12345double asr(double l,double r,double v)&#123; double mid=(l+r)/2,lv=simpson(l,mid),rv=simpson(mid,r); if (fabs(v-(lv+rv))&lt;eps) return lv+rv; else return asr(l,mid,lv)+asr(mid,r,rv);&#125; 通过二分的方法来进行精度的保证——在可控的时间内计算出正确的近似值。 来看洛谷的模板：[模板]自适应辛普森法 代码也很短： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define eps 1e-12using namespace std;double a,b,c,d,L,R;double f(double x)&#123; return (c*x+d)/(a*x+b);&#125;double simpson(double l,double r)&#123; return (r-l)*(f(r)+f(l)+4*f((l+r)/2))/6;&#125;double asr(double l,double r,double v)&#123; double mid=(l+r)/2,lv=simpson(l,mid),rv=simpson(mid,r); if (fabs(v-(lv+rv))&lt;eps) return lv+rv; else return asr(l,mid,lv)+asr(mid,r,rv);&#125;int main(void)&#123; scanf(\"%lf%lf%lf%lf%lf%lf\",&amp;a,&amp;b,&amp;c,&amp;d,&amp;L,&amp;R); printf(\"%.6lf\\n\",asr(L,R,simpson(L,R)));&#125; 洛谷还有另外一个模板题：[模板]自适应辛普森法2 $\\int_0^\\infty {f(x)}\\,{\\rm d}x​$ ($f(x)=x^{\\frac{a}{x}-x}​$) 这题没有上界——上界是无穷大。怎么办？ 我们来看一下这个$f(x)​$： 不难发现，$f(x)$如果将$x$取大，其函数值均为$0$。 那么这道题的策略就是取一个较大的上界，再用Simpson自适应公式求解。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define eps 1e-10using namespace std;double a;double f(double x)&#123; return pow(x,a/x-x);&#125;double simpson(double l,double r)&#123; return (r-l)*(f(l)+f(r)+4*f((l+r)/2))/6;&#125;double asr(double l,double r,double v)&#123; double mid=(l+r)/2,lv=simpson(l,mid),rv=simpson(mid,r); if (fabs(lv+rv-v)&lt;eps) return lv+rv; return asr(l,mid,lv)+asr(mid,r,rv);&#125;int main(void)&#123; scanf(\"%lf\",&amp;a); if (a&lt;0)&#123; puts(\"orz\"); return 0;&#125; printf(\"%.5f\",asr(eps,30,simpson(eps,30)));&#125; 再来看一道利用Simpson自适应公式的基础题：[HDU]Ellipse 大致题目如下： Math is important!! Many students failed in 2+2’s mathematical test, so let’s AC this problem to mourn for our lost youth..Look this sample picture: A ellipses in the plane and center in point O. the L,R lines will be vertical through the X-axis. The problem is calculating the blue intersection area. But calculating the intersection area is dull, so I have turn to you, a talent of programmer. Your task is tell me the result of calculations.(defined PI=3.14159265 , The area of an ellipse A=PIab ) 利用椭圆公式，就可以写出要积分的$f(x)$。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;int N;double a,b,L,R;double f(double x)&#123; return sqrt((a*a*b*b-b*b*x*x)/(a*a))*2;&#125;double simpson(double l,double r)&#123; return (r-l)*(f(l)+f(r)+4*f((l+r)/2))/6;&#125;double asr(double l,double r,double v)&#123; double mid=(l+r)/2,lv=simpson(l,mid),rv=simpson(mid,r); if (fabs(lv+rv-v)&lt;eps) return lv+rv; else return asr(l,mid,lv)+asr(mid,r,rv);&#125;int main(void)&#123; scanf(\"%d\",&amp;N); while (N--)&#123; scanf(\"%lf%lf%lf%lf\",&amp;a,&amp;b,&amp;L,&amp;R); printf(\"%.3f\\n\",asr(L,R,simpson(L,R))); &#125;&#125; 这些大致就是Simpson自适应公式的基础内容，感谢Willem大爷的谆谆教诲。 感谢！","link":"/2019/03/06/Simpson自适应公式-with-Willem/"},{"title":"邮局[ft.四边形不等式]","text":"题目描述一些村庄建在一条笔直的高速公路边上，我们用一条坐标轴来描述这条公路，每个村庄的坐标都是整数，没有两个村庄的坐标相同。两个村庄的距离定义为坐标之差的绝对值。我们需要在某些村庄建立邮局。使每个村庄使用与它距离最近的邮局，建立邮局的原则是：所有村庄到各自使用的邮局的距离总和最小。数据规模：1&lt;=村庄数&lt;=1600, 1&lt;=邮局数&lt;=200, 1&lt;=村庄坐标&lt;=maxlongint 输入2行 第一行:n m {表示有n个村庄，建立m个邮局} 第二行:a1 a2 a3 .. an {表示n个村庄的坐标} 输出1行第一行:l 个整数{表示最小距离总和} 样例输入 10 5 1 2 3 6 7 9 11 22 44 50 样例输出 9 这道题目是IOI2000的真题哦~ 可以这样考虑： 给定一个区间,假设我们要建一个邮局,那么一定是在这个序列的中点,所以我们可以先预处理出序列区间[i,j]之间的距离 一个邮局的最短距离记录为sum[i][j],然后用f[i][j]表示到i个村庄建立j个邮局的最短距离和,那么就有状态转移方程: 1f[i][j]=min(f[i][j],f[k][j-1]+sum[k+1][i]); 这样，代码就好写了。 但是——这个数据，用O(n3) 的普通DP算法显然无法通过。 O(n3) 代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std; int n,m;int a[1666];long long sum[1666]1666];long long f[1666][222];//f[i][j]表示前i个村庄设j个邮局//sum[i][j]表示在第i个村庄到第j个村庄设一个邮局的路程int main(void)&#123; cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); for (int i=1;i&lt;=n;i++)&#123; for (int j=i;j&lt;=n;j++)&#123; sum[i][j]=dis(i,j); &#125; &#125; memset(f,0x3f,sizeof(f)); for (int i=1;i&lt;=n;i++)&#123; f[i][1]=sum[1][i]; &#125; for (int i=1;i&lt;=n;i++)&#123; for (int j=2;j&lt;=min(i,m);j++)&#123; for (int k=j-1;k&lt;=i-1;k++)&#123; f[i][j]=min(f[i][j],f[k][j-1]+sum[k+1][i]); &#125; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl;&#125; 这东西肯定过不了啊~ 那怎么办？”四边形不等式！” f[a][c]+f[b][d]&lt;=f[b][c]+f[a][d]（ a &lt; b &lt;= c&lt; d ） （可以理解成：交叉小于包含） 满足这个条件的DP方程（或者说是别的什么数组啊之类的）就称为***为凸。 （以下一段文字来自这里 ） 给出两个定理： 1、如果上述的w函数同时满足区间包含单调性和四边形不等式性质，那么函数dp也满足四边形不等式性质 我们再定义s(i,j)表示 dp(i,j) 取得最优值时对应的下标（即 i≤k≤j 时，k 处的 dp 值最大，则 s(i,j)=k此时有如下定理 2、假如dp(i,j)满足四边形不等式，那么s(i,j)单调，即 s(i,j)≤s(i,j+1)≤s(i+1,j+1) 大家可以自己尝试推倒一下，为什么f[i][j]和sum[i][j]是满足这个式子的（因为我懒得再推了） 再就是要证明”决策单调” （以下一段文字来自这里 ） 如果我们用s[i][j]表示dp[i][j]取得最优解的时候k的位置的话 如果我们用s[i][j]表示dp[i][j]取得最优解的时候k的位置的话 那么我们要证明如下结论的成立性： s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j] s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j] s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j]对于s[i][j-1]&lt;=s[i][j]来说，我们先令dp[i][j-1]取得最优解的时候的k值为y，然后令除了最优值以外的其他值可以为x，这里我们由于要讨论单调性，所以让x小于y，即x&lt;=y&lt;=j-1&lt; j 这里的证明更为繁琐，在实际应用中，我们可以写出O(n3)后，自己跑一边是否决策单调，不是就输出”false”就行了。 在这道题中，我们要注意三点： s数组（决策数组）的初始化 循环的次序 对邮局多于村庄的特判（血泪） 话不多说，代码上 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[1606];long long sum[1606][1606];long long f[1606][202];int s[1606][202];//s是决策数组int main(void)&#123; cin&gt;&gt;n&gt;&gt;m; if(m&gt;=n)&#123; printf(\"0\"); return 0; &#125; for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); for (int i=1;i&lt;=n;i++)&#123; sum[i][i]=0; for (int j=i+1;j&lt;=n;j++)&#123; sum[i][j]=sum[i][j-1]+a[j]-a[(i+j)/2]; &#125; &#125; memset(f,0x3f,sizeof(f));//注意这里f要初始化成最大值 memset(s,0,sizeof(s)); for (int i=1;i&lt;=n;i++)&#123; f[i][1]=sum[1][i]; s[i][1]=0; &#125; for (int j=2;j&lt;=m;j++)&#123; s[n+1][j]=n; for (int i=n;i&gt;=j;i--)&#123; for (int k=s[i][j-1];k&lt;=s[i+1][j];k++)&#123; if (f[k][j-1]+sum[k+1][i]&lt;f[i][j])&#123; f[i][j]=f[k][j-1]+sum[k+1][i]; s[i][j]=k; &#125; &#125; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl;&#125; 这样的代码，经过四边形不等式的优化，就是O(n2)的算法了！ （以下一段文字来自这里 ） 关于O（n^2）复杂度的证明 其实证明很简单，对于一个i，j来说，我们要for s[i][j-1]到s[i+1][j]个数，那么所有的i和j加起来一共会for多少次呢？ 我们可以这样思考 (s[2][2]-[1][1])+(s[3][3]-s[2][2])+(s[4][4]-s[3][3])+…+(s[n][n]-s[n-1][n-1])=s[n][n]-s[1][1]很显然是小于n的嘛，所以本来是（n n n）的复杂度，就这样降成了O（n *n）啦 参阅：https://blog.csdn.net/noiau/article/details/72514812","link":"/2018/10/18/邮局-四边形不等式/"}],"tags":[],"categories":[]}