{"pages":[{"title":"Music","text":"Music Recommendation Weekly","link":"/Music/index.html"},{"title":"About","text":"","link":"/About/index.html"},{"title":"Friends","text":"","link":"/Friends/index.html"}],"posts":[{"title":"First Blog","text":"","link":"/2018/10/18/First Blog/"},{"title":"Splay基本操作[ft.指针]","text":"[怎么用C++自带的指针写数据结构？] [不会……那就快点学！不要颓！] 第一次用指针完成高级数据结构の[Splay]Splay食用须知首先，我们要理解什么是Splay树。Splay树是一棵二叉搜索树：二叉搜索树，用LJ的话讲，就是“左边比它小，右边比他大”。我们考虑这样一棵树，树上的任意一个节点满足“他的左子树上的每一个节点的值都比该节点的值小，他的右子树上的每一个节点的值都比该节点的值大”。就像这样： 如果这棵二叉搜索树是完全二叉树的话，很显然，查找一个值的时间是O(logn)。但是万一数据使这棵树被构造成一条链的话(例如最小的元素为根节点，次小的元素是它的左节点，以此类推)，查询一个值的时间复杂度会退化为O(n)，你就会获得0分的好成绩。 那么Splay树如何解决这个问题呢？旋转！每一次操作都旋转！跳跃！闭着眼！把节点旋转到根！在这里，我们把将某一个节点旋转到另一个位置，并且使这棵树保留原来的性质的操作，称为Splay。旋转降低复杂度(玄学)，对OIer来讲是无须证明，只要记住就好了，(如果你一定要看证明，你会回来的)。可以感性理解一下，每次操作改变一次结构，被查询频率高的条目会更靠近树根，时间有多有少，平均下来复杂度就会比较低（另外，Splay操作是单旋还是双旋也会影响到复杂度）。 成员变量我们先考虑Splay树上每一个点应该包含这几个成员变量：1234567891011class node&#123;public: int val,cnt,siz; node* fth; node* son[2]; node(int v=0,node *f=NULL)&#123; val=v;fth=f; son[0]=son[1]=NULL; cnt=siz=0; &#125;&#125; val:该点的值 cnt:值为该点的值的个数 siz:包括该点与其左右子树的大小 fth:爸爸指向该点的父节点的指针 son:指向该点的左右子节点的指针([0]左[1]右) Rotate[单旋]现在我们考虑将一个点旋转到它的父节点的位置:我们称其为Rotate。左子节点旋转到父节点称为右旋，右子节点旋转到父节点称为左旋。 在看Rotate的具体步骤之前，我们先介绍这个函数： 123bool sn(void)&#123; return (fth-&gt;son[1]==this);&#125; (注:这个函数是node这个类的成员函数，this是指向自己的指针，可以删去，下面的Rotate函数和Splay函数同理，不清楚可以看文章最后的全代码) 这个函数Sn可以方便地判断this是其父节点的哪个儿子，并返回该儿子的下标。 12345678910111213void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; y-&gt;updata(),this-&gt;updata();&#125; 其中注意，我们可以通过Sn()这个函数判断this是它父节点的哪一个子节点，以此来判断是左旋还是右旋，就不用累赘地写两个函数了。 这样，我们就完成单旋了。单旋Splay就是对某一个节点疯狂做单旋直到它变到目标位置。在多年(我考了十八年NOIP了，连复赛的机子都没摸到过)OI学习中，我们可以感觉到，做事不·能太暴力，单旋Splay是不能彻底改变树的结构的，(稍微卡一卡就咕咕)，于是我们引入了：“双旋Splay”，来彻底做到玄学复杂度。 Splay[双旋] 我们先观察上面的两张图，这次我们要考虑x(this)节点的父亲节点和祖父节点，分别命名为P，Q。如果x和p是同一种子节点(左/右子节点)，执行Zig-Zig操作，将x旋转到Q的位置，反之，执行Zig-Zag操作，将x旋转到Q的位置。这样子旋转两次直到x被旋转到目标节点——这就是双旋Splay。每次做两个Rotate操作，但是要注意的是，如果x与目标节点的深度只差1时，只用执行一次Rotate操作就可以了。(这样就可以保证复杂度的玄学了！) Zig-Zig操作：先旋转P节点，再旋转X节点； Zig-Zag操作：旋转两次X节点。 123456789101112131415161718bool splay(node* y=NULL)&#123; while(this-&gt;fth!=y)&#123; if (this-&gt;fth==NULL) return false; node *p=this-&gt;fth; if (p-&gt;fth==y || p-&gt;fth==NULL)&#123; this-&gt;rotate(); continue; &#125; node *q=p-&gt;fth; if (this-&gt;sn()!=p-&gt;sn())&#123; this-&gt;rotate(); this-&gt;rotate(); &#125; else&#123; p-&gt;rotate(); this-&gt;rotate(); &#125; &#125; return true;&#125; (这里我们考虑返回Bool值，在x转不到目标节点的情况能做出判断，用处不大) 这样子，我们的类-Node就打好了！这样就完成了一个Splay的框架。 类Node的完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class node&#123;public: int val,cnt,siz; node* fth; node* son[2]; node(int v=0,node *f=NULL)&#123; val=v;fth=f; son[0]=son[1]=NULL; cnt=siz=0; &#125;private: bool sn(void)&#123; return (fth-&gt;son[1]==this); &#125; void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; &#125;public: bool splay(node* y=NULL)&#123; while(this-&gt;fth!=y)&#123; if (this-&gt;fth==NULL) return false; node *p=this-&gt;fth; if (p-&gt;fth==y || p-&gt;fth==NULL)&#123; this-&gt;rotate(); continue; &#125; node *q=p-&gt;fth; if (this-&gt;sn()!=p-&gt;sn())&#123; this-&gt;rotate(); this-&gt;rotate(); &#125; else&#123; p-&gt;rotate(); this-&gt;rotate(); &#125; &#125; return true; &#125;&#125;; Insert[插入][在一个二叉搜索树中如何插入一个新的节点？] [找到你的归宿，一层一层剥开。] 对于一个Splay树，我们只记录他的根节点，由root指针指向。所以做什么操作，都要从源头开始。从根出发，如果比根大，就往根的右子树里找，如果比根小，就往根的左子树找。 在树状结构中，这样的查找是不是让人很想用递归实现啊？ 12345678910111213void _insert(int v,node *p,node *f)&#123; if (p==NULL)&#123; p=new node(v,f); p-&gt;splay(); root=p; return; &#125; if (v==p-&gt;val)&#123; p-&gt;cnt++; return; &#125; if (v&lt;p-&gt;val) _insert(v,p-&gt;son[0],p); if (v&gt;p-&gt;val) _insert(v,p-&gt;son[1],p);&#125; 但是其实可以用循环实现哦~这样子调用函数，传入多个参数，又慢又丑陋，不如这样写: 12345678910111213void insert(int v)&#123; if (root==NULL) root=new node(v,NULL); for (node *t=root;;t=t-&gt;son[v&gt;=t-&gt;val])&#123; if(t-&gt;val==v)&#123; root=t; t-&gt;cnt++; t-&gt;splay(); return; &#125; if (t-&gt;son[v&gt;=t-&gt;val]==NULL)&#123; t-&gt;son[v&gt;=t-&gt;val]=new node(v,t); &#125; &#125;&#125; 如果原有该值的点，则直接cnt++，如果没有，则new一个新的点再cnt++。 (不管怎么样，操作中都要Splay操作结点) Find[查找]从root往下找，走向son[v&gt;t-&gt;val]——当v大于当前节点的val时，返回1：走向右子树；当v小于当前节点的val时，返回0：走向左子树。 12345678910node* find(int v)&#123; for(node* t=root;t;t=t-&gt;son[v&gt;t-&gt;val])&#123; if(t-&gt;val==v)&#123; t-&gt;splay(); root=t; return t; &#125; &#125; return NULL;&#125; Erase[删除]先Splay要删去的节点——好，现在我们要删去的节点在根节点上。 接下来，在他的左子树中找到最大的那个节点，（如果没有左子树的话就直接删去根节点就行了），将那个节点Splay到根节点的右子节点，那么此时这个节点是没有右子树的——将根节点的左子树指向这个节点，干脆利落地删除根节点，删除操作完成！ size[子树大小]在这里，我们在node类中引入updata函数，在Rotate操作中将改变的size值更新。 1234void updata(void)&#123; siz=(son[0]?son[0]-&gt;siz:0) +(son[1]?son[1]-&gt;siz:0)+cnt;&#125; 这是改变后的Rotate操作： 12345678910111213void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; y-&gt;updata(),this-&gt;updata();&#125; 那么返回一个节点及其子树的Size就非常简单了。 123456int size(void)&#123; return root-&gt;siz;&#125;int size(node* x)&#123; return x-&gt;siz;&#125; #####Kth[第K大数] 如果K在根节点的cnt区间内，则返回根节点; 如果K在左子树区间内，递归处理左子树; 如果K在右子树区间内，将在之后的递归中加入当前左子树和根节点的值，递归处理右子树。 递归处理，简单明了。 1234567891011121314151617int kth(int key)&#123; int cnt=0; if (key&gt;root-&gt;siz) return -1; for (node* i=root;i;)&#123; int lcnt=(i-&gt;son[0])?i-&gt;son[0]-&gt;siz:0; int mcnt=i-&gt;cnt; if (cnt+lcnt&lt;key &amp;&amp; cnt+lcnt+mcnt&gt;=key)&#123; i-&gt;splay(); return i-&gt;val; &#125; if (cnt+lcnt&gt;=key) i=i-&gt;son[0]; if (key&gt;cnt+lcnt+mcnt)&#123; cnt+=lcnt+mcnt; i=i-&gt;son[1]; &#125; &#125;&#125; Next[前驱/后继]找前驱，在该节点的左子树中向右子树找，找出左子树中最大的节点。 找前驱，在该节点的右子树中向左子树找，找出右子树中最小的节点。 1234567node* next(node* x,int s)&#123; //s=0表示前驱，s=1表示后继 node* t=x-&gt;son[s]; if (!t) return NULL; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; t-&gt;splay(); return t;&#125; 与Find函数结合，可以先找到该节点，再进行Next操作。 1234567int next(int ix,int s)&#123; //s=0表示前驱，s=1表示后继 node* x=find(ix); node* t=x-&gt;son[s]; if (!t) return -1; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; return t-&gt;val;&#125; Main[主程序]这样，我们的Splay就支持了以下操作： Erase Insert Find Size Kth Next 1234567891011121314151617181920212223242526272829303132333435363738394041int n,tmp,z;string s;Splay tr;int main(void)&#123; for(;;)&#123; cin&gt;&gt;s; if (s==\"erase\")&#123; cin&gt;&gt;tmp; tr.erase(tmp); tr.print(); &#125; if (s==\"insert\")&#123; cin&gt;&gt;tmp; tr._insert(tmp,tr.root,NULL); tr.print(); &#125; if (s==\"find\")&#123; cin&gt;&gt;tmp; if (tr.find(tmp)) cout&lt;&lt;\"true\\n\"; else cout&lt;&lt;\"false\\n\"; tr.print(); &#125; if (s==\"size\")&#123; cout&lt;&lt;tr.size()&lt;&lt;endl; tr.print(); &#125; if (s==\"kth\")&#123; cin&gt;&gt;tmp; cout&lt;&lt;tr.kth(tmp)&lt;&lt;endl; tr.print(); &#125; if (s==\"next\")&#123; cin&gt;&gt;tmp&gt;&gt;z; cout&lt;&lt;tr.next(tmp,z)&lt;&lt;endl; tr.print(); &#125; if (s==\"exit\")&#123; return 0; &#125; &#125;&#125; 完整程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include&lt;bits/stdc++.h&gt;//祈福无Bugusing namespace std;struct node&#123;public: int val,cnt,siz; node* fth; node* son[2]; node(int v=0,node *f=NULL)&#123; val=v;fth=f; son[0]=son[1]=NULL; cnt=siz=0; &#125;private: bool sn(void)&#123; return (fth-&gt;son[1]==this); &#125; void updata(void)&#123; siz=(son[0]?son[0]-&gt;siz:0) +(son[1]?son[1]-&gt;siz:0)+cnt; &#125; void rotate(void)&#123; node *y=this-&gt;fth; bool a=this-&gt;sn(); y-&gt;son[a]=this-&gt;son[!a]; if (this-&gt;son[!a]!=NULL) this-&gt;son[!a]-&gt;fth=y; this-&gt;fth=y-&gt;fth; if (y-&gt;fth!=NULL) y-&gt;fth-&gt;son[y-&gt;sn()]=this; this-&gt;son[!a]=y; y-&gt;fth=this; y-&gt;updata(),this-&gt;updata(); &#125;public: bool splay(node* y=NULL)&#123; while(this-&gt;fth!=y)&#123; if (this-&gt;fth==NULL) return false; node *p=this-&gt;fth; if (p-&gt;fth==y || p-&gt;fth==NULL)&#123; this-&gt;rotate(); continue; &#125; node *q=p-&gt;fth; if (this-&gt;sn()!=p-&gt;sn())&#123; this-&gt;rotate(); this-&gt;rotate(); &#125; else&#123; p-&gt;rotate(); this-&gt;rotate(); &#125; &#125; return true; &#125;&#125;;struct Splay&#123; node *root; Splay(node *p=NULL)&#123; root=NULL; &#125; int size(void)&#123; return root-&gt;siz; &#125; int size(node* x)&#123; return x-&gt;siz; &#125; void _print(node *x)&#123; if (x==NULL) return; cout&lt;&lt;x-&gt;val&lt;&lt;\" \"; if (x-&gt;son[0]!=NULL) cout&lt;&lt;\"Left:\"&lt;&lt;x-&gt;son[0]-&gt;val&lt;&lt;\" \"; else cout&lt;&lt;\"Left:NULL \"; if (x-&gt;son[1]!=NULL) cout&lt;&lt;\"Right:\"&lt;&lt;x-&gt;son[1]-&gt;val&lt;&lt;\" \"; else cout&lt;&lt;\"Right:NULL \"; cout&lt;&lt;\"\\n\"; _print(x-&gt;son[0]);_print(x-&gt;son[1]); &#125; void print(void)&#123; _print(root); &#125; void insert(int v=0)&#123; if (root==NULL) root=new node(v,NULL); for (node *t=root;;t=t-&gt;son[v&gt;=t-&gt;val])&#123; if(t-&gt;val==v)&#123; root=t; t-&gt;cnt++; t-&gt;splay(); return; &#125; if (t-&gt;son[v&gt;=t-&gt;val]==NULL)&#123; t-&gt;son[v&gt;=t-&gt;val]=new node(v,t); &#125; &#125; &#125; void _insert(int v,node *p,node *f)&#123; if (p==NULL)&#123; p=new node(v,f); p-&gt;splay(); root=p; return; &#125; if (v&lt;p-&gt;val) _insert(v,p-&gt;son[0],p); if (v==p-&gt;val)&#123; p-&gt;cnt++; return; &#125; if (v&gt;p-&gt;val) _insert(v,p-&gt;son[1],p); &#125; node* find(int v)&#123; for(node* t=root;t;t=t-&gt;son[v&gt;t-&gt;val])&#123; if(t-&gt;val==v)&#123; t-&gt;splay(); root=t; return t; &#125; &#125; return NULL; &#125; bool erase(int v,int cnt=1)&#123; node *t=find(v); if (t==NULL)&#123; return false; &#125; if (t-&gt;cnt&gt;cnt)&#123; t-&gt;cnt-=cnt; return true; &#125; if (t-&gt;son[0]==NULL)&#123; root=t-&gt;son[1]; if (root!=NULL) root-&gt;fth=NULL; return true; &#125; node *p=t-&gt;son[0]; while(p-&gt;son[1]!=NULL) p=p-&gt;son[1]; p-&gt;splay(t); root=p; root-&gt;fth=NULL; p-&gt;son[1]=t-&gt;son[1]; if (p-&gt;son[1]!=NULL) p-&gt;son[1]-&gt;fth=p; return true; &#125; int kth(int key)&#123; int cnt=0; if (key&gt;root-&gt;siz) return -1; for (node* i=root;i;)&#123; int lcnt=(i-&gt;son[0])?i-&gt;son[0]-&gt;siz:0; int mcnt=i-&gt;cnt; if (cnt+lcnt&lt;key &amp;&amp; cnt+lcnt+mcnt&gt;=key)&#123; i-&gt;splay(); return i-&gt;val; &#125; if (cnt+lcnt&gt;=key) i=i-&gt;son[0]; if (key&gt;cnt+lcnt+mcnt)&#123; cnt+=lcnt+mcnt; i=i-&gt;son[1]; &#125; &#125; &#125; node* next(node* x,int s)&#123; //s=0表示前驱，s=1表示后继 node* t=x-&gt;son[s]; if (!t) return NULL; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; t-&gt;splay(); return t; &#125; int next(int ix,int s)&#123; //s=0表示前驱，s=1表示后继 node* x=find(ix); node* t=x-&gt;son[s]; if (!t) return -1; while (t-&gt;son[s^1]) t=t-&gt;son[s^1]; return t-&gt;val; &#125;&#125;;int n,tmp,z;string s;Splay tr;int main(void)&#123; for(;;)&#123; cin&gt;&gt;s; if (s==\"erase\")&#123; cin&gt;&gt;tmp; tr.erase(tmp); tr.print(); &#125; if (s==\"insert\")&#123; cin&gt;&gt;tmp; tr._insert(tmp,tr.root,NULL); tr.print(); &#125; if (s==\"find\")&#123; cin&gt;&gt;tmp; if (tr.find(tmp)) cout&lt;&lt;\"true\\n\"; else cout&lt;&lt;\"false\\n\"; tr.print(); &#125; if (s==\"size\")&#123; cout&lt;&lt;tr.size()&lt;&lt;endl; tr.print(); &#125; if (s==\"kth\")&#123; cin&gt;&gt;tmp; cout&lt;&lt;tr.kth(tmp)&lt;&lt;endl; tr.print(); &#125; if (s==\"next\")&#123; cin&gt;&gt;tmp&gt;&gt;z; cout&lt;&lt;tr.next(tmp,z)&lt;&lt;endl; tr.print(); &#125; if (s==\"exit\")&#123; return 0; &#125; &#125;&#125; 下一篇文章:Splay区间操作[ft.指针]，过几天会咕咕咕地更新哦。","link":"/2018/10/23/Splay基本操作-ft-指针/"},{"title":"邮局-四边形不等式","text":"题目描述一些村庄建在一条笔直的高速公路边上，我们用一条坐标轴来描述这条公路，每个村庄的坐标都是整数，没有两个村庄的坐标相同。两个村庄的距离定义为坐标之差的绝对值。我们需要在某些村庄建立邮局。使每个村庄使用与它距离最近的邮局，建立邮局的原则是：所有村庄到各自使用的邮局的距离总和最小。数据规模：1&lt;=村庄数&lt;=1600, 1&lt;=邮局数&lt;=200, 1&lt;=村庄坐标&lt;=maxlongint 输入2行 第一行:n m {表示有n个村庄，建立m个邮局} 第二行:a1 a2 a3 .. an {表示n个村庄的坐标} 输出1行第一行:l 个整数{表示最小距离总和} 样例输入 10 5 1 2 3 6 7 9 11 22 44 50 样例输出 9 这道题目是IOI2000的真题哦~ 可以这样考虑： 给定一个区间,假设我们要建一个邮局,那么一定是在这个序列的中点,所以我们可以先预处理出序列区间[i,j]之间的距离 一个邮局的最短距离记录为sum[i][j],然后用f[i][j]表示到i个村庄建立j个邮局的最短距离和,那么就有状态转移方程: 1f[i][j]=min(f[i][j],f[k][j-1]+sum[k+1][i]); 这样，代码就好写了。 但是——这个数据，用O(n3) 的普通DP算法显然无法通过。 O(n3) 代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std; int n,m;int a[1666];long long sum[1666]1666];long long f[1666][222];//f[i][j]表示前i个村庄设j个邮局//sum[i][j]表示在第i个村庄到第j个村庄设一个邮局的路程int main(void)&#123; cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); for (int i=1;i&lt;=n;i++)&#123; for (int j=i;j&lt;=n;j++)&#123; sum[i][j]=dis(i,j); &#125; &#125; memset(f,0x3f,sizeof(f)); for (int i=1;i&lt;=n;i++)&#123; f[i][1]=sum[1][i]; &#125; for (int i=1;i&lt;=n;i++)&#123; for (int j=2;j&lt;=min(i,m);j++)&#123; for (int k=j-1;k&lt;=i-1;k++)&#123; f[i][j]=min(f[i][j],f[k][j-1]+sum[k+1][i]); &#125; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl;&#125; 这东西肯定过不了啊~ 那怎么办？”四边形不等式！” f[a][c]+f[b][d]&lt;=f[b][c]+f[a][d]（ a &lt; b &lt;= c&lt; d ） （可以理解成：交叉小于包含） 满足这个条件的DP方程（或者说是别的什么数组啊之类的）就称为***为凸。 （以下一段文字来自这里 ） 给出两个定理： 1、如果上述的w函数同时满足区间包含单调性和四边形不等式性质，那么函数dp也满足四边形不等式性质 我们再定义s(i,j)表示 dp(i,j) 取得最优值时对应的下标（即 i≤k≤j 时，k 处的 dp 值最大，则 s(i,j)=k此时有如下定理 2、假如dp(i,j)满足四边形不等式，那么s(i,j)单调，即 s(i,j)≤s(i,j+1)≤s(i+1,j+1) 大家可以自己尝试推倒一下，为什么f[i][j]和sum[i][j]是满足这个式子的（因为我懒得再推了） 再就是要证明”决策单调” （以下一段文字来自这里 ） 如果我们用s[i][j]表示dp[i][j]取得最优解的时候k的位置的话 如果我们用s[i][j]表示dp[i][j]取得最优解的时候k的位置的话 那么我们要证明如下结论的成立性： s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j] s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j] s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j]对于s[i][j-1]&lt;=s[i][j]来说，我们先令dp[i][j-1]取得最优解的时候的k值为y，然后令除了最优值以外的其他值可以为x，这里我们由于要讨论单调性，所以让x小于y，即x&lt;=y&lt;=j-1&lt; j 这里的证明更为繁琐，在实际应用中，我们可以写出O(n3)后，自己跑一边是否决策单调，不是就输出”false”就行了。 在这道题中，我们要注意三点： s数组（决策数组）的初始化 循环的次序 对邮局多于村庄的特判（血泪） ​ 话不多说，代码上 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[1606];long long sum[1606][1606];long long f[1606][202];int s[1606][202];//s是决策数组int main(void)&#123; cin&gt;&gt;n&gt;&gt;m; if(m&gt;=n)&#123; printf(\"0\"); return 0; &#125; for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); for (int i=1;i&lt;=n;i++)&#123; sum[i][i]=0; for (int j=i+1;j&lt;=n;j++)&#123; sum[i][j]=sum[i][j-1]+a[j]-a[(i+j)/2]; &#125; &#125; memset(f,0x3f,sizeof(f));//注意这里f要初始化成最大值 memset(s,0,sizeof(s)); for (int i=1;i&lt;=n;i++)&#123; f[i][1]=sum[1][i]; s[i][1]=0; &#125; for (int j=2;j&lt;=m;j++)&#123; s[n+1][j]=n; for (int i=n;i&gt;=j;i--)&#123; for (int k=s[i][j-1];k&lt;=s[i+1][j];k++)&#123; if (f[k][j-1]+sum[k+1][i]&lt;f[i][j])&#123; f[i][j]=f[k][j-1]+sum[k+1][i]; s[i][j]=k; &#125; &#125; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl;&#125; 这样的代码，经过四边形不等式的优化，就是O(n2)的算法了！ （以下一段文字来自这里 ） 关于O（n^2）复杂度的证明 其实证明很简单，对于一个i，j来说，我们要for s[i][j-1]到s[i+1][j]个数，那么所有的i和j加起来一共会for多少次呢？ 我们可以这样思考 (s[2][2]-[1][1])+(s[3][3]-s[2][2])+(s[4][4]-s[3][3])+…+(s[n][n]-s[n-1][n-1])=s[n][n]-s[1][1]很显然是小于n的嘛，所以本来是（n n n）的复杂度，就这样降成了O（n *n）啦 参阅：https://blog.csdn.net/noiau/article/details/72514812","link":"/2018/10/18/邮局-四边形不等式/"}],"tags":[],"categories":[]}